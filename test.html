
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - draggable cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div style="margin-left: 25%">
			<button onclick="toFrontView();">toFront</button>
			<button onclick="toRight();">toRight</button>
			<button onclick="toTop();">toTop</button>
		</div>
		<script src="three.js"></script>
		<script src="TrackballControls.js"></script>
		<script src="stats.min.js"></script>
		<script src="CombinedCamera.js"></script>

		<script>

			print4x4Matrix = function(mat) {
				var print = '-           -\n';
				print += '| ' + mat.elements[0] + '\t' + mat.elements[1] + '\t' + mat.elements[2] + '\t' + mat.elements[3] + ' |\n';
				print += '| ' + mat.elements[4] + '\t' + mat.elements[5] + '\t' + mat.elements[6] + '\t' + mat.elements[7] + ' |\n';
				print += '| ' + mat.elements[8] + '\t' + mat.elements[9] + '\t' + mat.elements[10] + '\t' + mat.elements[11] + ' |\n';
				print += '| ' + mat.elements[12] + '\t' + mat.elements[13] + '\t' + mat.elements[14] + '\t' + mat.elements[15] + ' |\n';
				print += '-           -\n';
				console.log(print);
			}
			var xAxis = new THREE.Vector3(1,0,0), yAxis = new THREE.Vector3(0,1,0), zAxis = new THREE.Vector3(0,0,1);
			var size = 1000, step = 10;
			var container, stats;
			var camera, controls, scene, renderer;
			var rotating = false, dragging = false;
			var objects = [];
			var delta = 10;
			var gridHelper;
			var plane = new THREE.Plane();
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2(),
			offset = new THREE.Vector3(),
			intersection = new THREE.Vector3(),
			INTERSECTED, SELECTED;
			var previousMousePosition = { x: 0, y: 0 };

			init();
			animate();

			toFrontView = function() {
				camera.position.set(0,0,farthestDistanceFromOrigin(camera));
				camera.rotation.set(0,0,0);
				//camera.up = new THREE.Vector3(0,0,1);
				console.log('down' , camera.position, camera.rotation, print4x4Matrix(camera.matrix));
				//camera.lookAt(new THREE.Vector3(0,0,0));
			}
			toRight = function() {
				camera.position.set(farthestDistanceFromOrigin(camera),0,0);
				camera.rotation.set(0,0,0);
				//camera.up = new THREE.Vector3(0,0,1);
				console.log('down' , camera.position, camera.rotation, print4x4Matrix(camera.matrix));
				//camera.lookAt(new THREE.Vector3(0,0,0));
			}
			toTop = function() {
				camera.position.set(0,farthestDistanceFromOrigin(camera),0);
				camera.rotation.set(0,0,0);
				//camera.up = new THREE.Vector3(0,0, 1);
				console.log('down' , camera.position, camera.rotation, print4x4Matrix(camera.matrix));
				//camera.lookAt(new THREE.Vector3(0,0,0));
			}

			farthestDistanceFromOrigin = function(camera) {
				var ret = 0;
				if (camera.position.x > ret)
					ret = camera.position.x; 
				if (camera.position.y > ret)
					ret = camera.position.y;
				if (camera.position.z > ret)
					ret = camera.position.z;  
				return ret;				
			}


			function init() {

				document.addEventListener('keydown',onDocumentKeyDown,false);
				function onDocumentKeyDown(event){
					event = event || window.event;

					switch(event.key){
						case 'ArrowUp' :
							// move in the +z direction of current camera angle
							camera.position.y = camera.position.y + delta;
							break;
						case 'ArrowDown' :
							camera.position.y = camera.position.y - delta;
							break;
						case 'ArrowRight' :
							camera.position.x = camera.position.x + delta;
							break;
						case 'ArrowLeft' :
							camera.position.x = camera.position.x - delta;
							break;
						case 's' :
							camera.position.z = camera.position.z + delta;
							break;
						case 'w' :
							camera.position.z = camera.position.z - delta;
							break;
						case 'r' :
							dragging = false;
							rotating = !rotating;
							break;
						case 'd' :
							rotating = false;
							dragging = !dragging;
							break;			
						case '1' : 	// remvoe z rotation 
							rotateAroundWorldAxis(SELECTED, zAxis, 0);
							break;
						case '2' :
							dragging = !dragging;
							break;
						case '3' :
							rotating = !rotating;
							break;
						case '4' :
							dragging = !dragging;
							break;
					}
					console.log('down' , event, camera.position, camera.rotation, print4x4Matrix(camera.matrix));
				}

				// document.addEventListener('keyup',onDocumentKeyUp,false);
				// function onDocumentKeyUp(event){
				// 	event = event || window.event;

				// 	switch(event.key){
				// 		case 'r' :
				// 			rotating = false;
				// 			break;
				// 		case 'd' :
				// 			dragging = false;
				// 			break;							
				// 	}
				// }

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 10000);
				camera.position.x = 1000;
				camera.position.y = 1000;
				camera.position.z = 1000;
				//camera.up = new THREE.Vector3( 0, 0, 1 );
				// camera.position.x = 500;
				// camera.position.y = 500;
				// camera.position.z = 500;
				//camera.up.set( 0, 0, 1 );


				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );



				gridHelper = new THREE.GridHelper(size, step, 0x000000, 0xff0000);
				scene.add( gridHelper );

				var geometry = new THREE.BoxGeometry( 40, 40, 40 );

				// create object
				var xobj = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0xff0000 } ) );
				xobj.position.x = 200;
				xobj.position.y = 0;
				xobj.position.z = 0;

				xobj.rotation.x = 0;
				xobj.rotation.y = 0;
				xobj.rotation.z = 0;

				xobj.scale.x = 1;
				xobj.scale.y = 1;
				xobj.scale.z = 1;

				scene.add(xobj);
				objects.push(xobj);

				var yobj = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x00ff00 } ) );
				yobj.position.x = 0;
				yobj.position.y = 200;
				yobj.position.z = 0;

				yobj.rotation.x = 0;
				yobj.rotation.y = 0;
				yobj.rotation.z = 0;

				yobj.scale.x = 1;
				yobj.scale.y = 1;
				yobj.scale.z = 1;

				scene.add(yobj);
				objects.push(yobj);

				var zobj = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x0000ff } ) );
				zobj.position.x = 0;
				zobj.position.y = 0;
				zobj.position.z = 200;

				zobj.rotation.x = 0;
				zobj.rotation.y = 0;
				zobj.rotation.z = 0;

				zobj.scale.x = 1;
				zobj.scale.y = 1;
				zobj.scale.z = 1;

				scene.add(zobj);
				objects.push(zobj);


				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> webgl - draggable cubes';
				container.appendChild( info );

				stats = new Stats();
				container.appendChild( stats.dom );

				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				console.log(camera.position);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );


				if (SELECTED) {
					if (rotating) {
						var deltaMove = {
					        x: event.offsetX-previousMousePosition.x,
					        y: event.offsetY-previousMousePosition.y
					    };

				        var deltaRotationQuaternion = new THREE.Quaternion()
				            .setFromEuler(new THREE.Euler(
				                toRadians(deltaMove.y * 1),
				                toRadians(deltaMove.x * 1),
				                0,
				                'XYZ'
				            ));
				        
				        SELECTED.quaternion.multiplyQuaternions(deltaRotationQuaternion, SELECTED.quaternion);
					    
					    previousMousePosition = {
					        x: event.offsetX,
					        y: event.offsetY
					    };
					}
					else if (dragging) {
						if ( SELECTED ) {
							if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
								SELECTED.position.copy( intersection.sub( offset ) );
							}
							return;
						}
					}
				}
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) 
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );
					}
					container.style.cursor = 'pointer';
				} else {
					if ( INTERSECTED ) 
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
					container.style.cursor = 'auto';
				}

			}

			function onDocumentMouseDown( event ) {
				event.preventDefault();
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {
					controls.enabled = false;
					SELECTED = intersects[ 0 ].object;
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						offset.copy( intersection ).sub( SELECTED.position );
					}
					container.style.cursor = 'move';
				}
			}

			function onDocumentMouseUp( event ) {
				event.preventDefault();
				controls.enabled = true;
				SELECTED = null;
				container.style.cursor = 'auto';
			}

			//

			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			function render() {
				controls.update();
				renderer.render( scene, camera );
			}

			function toRadians(angle) {
				return angle * (Math.PI / 180);
			}

			function toDegrees(angle) {
				return angle * (180 / Math.PI);
			}

			// Rotate an object around an arbitrary axis in object space
			var rotObjectMatrix;
			function rotateAroundObjectAxis(object, axis, radians) {
			    rotObjectMatrix = new THREE.Matrix4();
			    rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);

			    // old code for Three.JS pre r54:
			    // object.matrix.multiplySelf(rotObjectMatrix);      // post-multiply
			    // new code for Three.JS r55+:
			    object.matrix.multiply(rotObjectMatrix);

			    // old code for Three.js pre r49:
			    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
			    // old code for Three.js r50-r58:
			    // object.rotation.setEulerFromRotationMatrix(object.matrix);
			    // new code for Three.js r59+:
			    object.rotation.setFromRotationMatrix(object.matrix);
			}

			var rotWorldMatrix;
			// Rotate an object around an arbitrary axis in world space       
			function rotateAroundWorldAxis(object, axis, radians) {
			    rotWorldMatrix = new THREE.Matrix4();
			    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

			    // old code for Three.JS pre r54:
			    //  rotWorldMatrix.multiply(object.matrix);
			    // new code for Three.JS r55+:
			    rotWorldMatrix.multiply(object.matrix);                // pre-multiply

			    object.matrix = rotWorldMatrix;

			    // old code for Three.js pre r49:
			    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
			    // old code for Three.js pre r59:
			    // object.rotation.setEulerFromRotationMatrix(object.matrix);
			    // code for r59+:
			    object.rotation.setFromRotationMatrix(object.matrix);
			}			
		</script>

	</body>
</html>
